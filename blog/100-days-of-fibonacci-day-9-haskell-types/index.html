<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <script>
    // I have moved the blog
    let url = 'https://blog.madsbuch.com' + window.location.pathname.replace('/blog', '')
    window.location = url
  </script>

  <title>100 Days of Fibonacci - Day 9, Haskell Types</title>
  <meta name="description" content="Haskell has a flexible type system. It actually is Turing completegiven the right language extensions. This also means that we can doarbitrary computations, which we are going to exploit in this 10..." />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@madspbuch" />
    <meta name="twitter:title" content="100 Days of Fibonacci - Day 9, Haskell Types" />
    <meta name="twitter:image" content="http://madsbuch.com/blog/assets/images/logo.png" />
    
    <meta name="twitter:description"  content="Haskell has a flexible type system. It actually is Turing completegiven the right language extensions. This also means that we can doarbitrary computations, which we are going to exploit in this 10..." />
    
  
  
  <meta property="og:site_name" content="Mads Buch" />
  <meta property="og:title" content="100 Days of Fibonacci - Day 9, Haskell Types"/>
  
  <meta property="og:description" content="Haskell has a flexible type system. It actually is Turing completegiven the right language extensions. This also means that we can doarbitrary computations, which we are going to exploit in this 10..." />
  
  <meta property="og:image" content="http://madsbuch.com/blog/assets/images/logo.png" />
  <meta property="og:url" content="http://madsbuch.com/blog/100-days-of-fibonacci-day-9-haskell-types/" >
  <meta property="og:type" content="blog" />

  
  <meta property="fb:app_id" content="1727612590830968" />
  
  

  <meta property="article:published_time" content="2016-01-29T00:00:00+01:00">

  <link rel="canonical" href="http://madsbuch.com/blog/100-days-of-fibonacci-day-9-haskell-types/"/>
  <link rel="shortcut icon" href="/blog/assets/images/favicon.png" type="image/png"/>
  <link rel="stylesheet" href="//brick.a.ssl.fastly.net/Linux+Libertine:400,400i,700,700i/Open+Sans:400,400i,700,700i">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" type="text/css" media="screen" href="/blog/css/main.css" />
  <link rel="stylesheet" type="text/css" media="print" href="/blog/css/print.css" />
  <link rel="stylesheet" type="text/css" href="/blog/css/extra.css" />

  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3209922-9', 'auto');
  ga('send', 'pageview');

</script>
</head>

  <body itemscope itemtype="http://schema.org/Article">
    <!-- header start -->

<a href="http://madsbuch.com/blog" class="logo-readium">
    <span class="logo" style="background-image: url(/blog/assets/images/logo.png)"></span>
</a>

<!-- header end -->

    <main class="content" role="main">
      <article class="post">
        
        <div class="noarticleimage">
          <div class="post-meta">
            <h1 class="post-title">100 Days of Fibonacci - Day 9, Haskell Types</h1>
            <div class="cf post-meta-text">
              <div class="author-image" style="background-image: url(/blog/assets/images/author.png)">Blog Logo</div>
              <h4 class="author-name" itemprop="author" itemscope itemtype="http://schema.org/Person"></h4>
              on
              <time datetime="2016-01-29T00:00:00+01:00">29 Jan 2016</time>
              <!-- , tagged on <span class="post-tag-">, <a href="/tag/"></a></span> -->
            </div>
          </div>
        </div>
        <br>
        <br>
        <br>
        
        <section class="post-content">
          <div class="post-reading">
            <span class="post-reading-time"></span> read
          </div>
          <a name="topofpage"></a>
          <p>Haskell has a flexible type system. It actually is Turing complete
given the right language extensions. This also means that we can do
arbitrary computations, which we are going to exploit in this 10th 
day in my <a href="/blog/100-days-of-fibonacci-overview/">100 days of Fibonacci</a>
challenge.</p>

<p>I already did <a href="/blog/100-days-of-fibonacci-day-0-haskell/">look at Haskell</a>.
So strictly speaking I should choose another language.
However, I find that programming in Haskell’s type system is different
enough that I will consider it a different language.</p>

<h1 id="day-9---haskell-types">Day 9 - Haskell Types</h1>
<p>Today I implemented Fibonacci in the Haskell type system. That means that I
can get the Haskell compiler to generate a <em>type</em> for the <em>n</em>‘th
Fibonacci number.</p>

<p>I first created a datatype for representing naturals.
The approach as in the last part of the
<a href="/blog/100-days-of-fibonacci-day-4-prolog/">Prolog implementation</a> and
use used in <a href="/blog/100-days-of-fibonacci-day-7-coq/">Coq</a> was used.
This representation
builds on the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano axioms</a>
and is straight forward to implement.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="kr">data</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="kt">Z</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">Nat</span></code></pre></figure>

<p>This datatype is usable as a <a href="https://wiki.haskell.org/Kind">kind</a>
because we use the language extension <em>DataKinds</em>. A kind can be
thought of as a type of a type.</p>

<p>In <code class="highlighter-rouge">ghci</code> we can inspect the kind of the type constructor <code class="highlighter-rouge">Z</code> by issuing
<code class="highlighter-rouge">:kind Z</code>. The result returned is <code class="highlighter-rouge">Z :: Nat</code>.</p>

<p>Next I implemented addition. In Haskell we use the
language extension <em>TypeFamilies</em> to have a mechanism for implementing
type level functions.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="kr">type</span> <span class="n">family</span> <span class="kt">Add</span> <span class="p">(</span><span class="n">a</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Nat</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Add</span>  <span class="kt">Z</span>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">S</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span></code></pre></figure>

<p>Again we can try to inspect the kind of the type level function:
<code class="highlighter-rouge">:kind Add (S Z) (S Z)</code> which yields <code class="highlighter-rouge">Add (S Z) (S Z) :: Nat</code> as
expected.</p>

<p>To actually calculate the Fibonacci type we need Haskell to reduce the <code class="highlighter-rouge">Add</code>
expression. This is done using the <code class="highlighter-rouge">:kind! Add (S Z) (S Z)</code> operation.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"> 
<span class="k">*</span>FibType&gt; :kind! Add <span class="o">(</span>S Z<span class="o">)</span> <span class="o">(</span>S Z<span class="o">)</span>
Add <span class="o">(</span>S Z<span class="o">)</span> <span class="o">(</span>S Z<span class="o">)</span> :: Nat
<span class="o">=</span> <span class="s1">'S ('</span>S <span class="s1">'Z)</span></code></pre></figure>

<p>We can now both define type level datatypes (kinds) and do operations on these.
Along this line I implemented Fibonacci straight forward in direct recursion.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="kr">type</span> <span class="n">family</span> <span class="kt">Fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Nat</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Fibonacci</span> <span class="kt">Z</span>           <span class="o">=</span> <span class="kt">Z</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Fibonacci</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>       <span class="o">=</span> <span class="p">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="p">)</span>
<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">Fibonacci</span> <span class="p">(</span><span class="kt">S</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span>   <span class="o">=</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Fibonacci</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="kt">Fibonacci</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">))</span></code></pre></figure>

<p>To implement above type family I had to add the language extension
<em>UndecidableInstances</em>. This is because of the use of the <code class="highlighter-rouge">Add</code> type
family in the <code class="highlighter-rouge">Fibonacci</code> type family.</p>

<p>In this example, however, it is easy to see that the type family will
always converge. <code class="highlighter-rouge">Add</code> converges (and does not need
<em>UndecidableInstances</em>) and <code class="highlighter-rouge">Fibonacci</code> converges as the arguments
to the recursive applications are decreasing.</p>

<p>The last thing is to actually calculate Fibonacci. This can be done by
issuing the <code class="highlighter-rouge">:kind!</code> as earlier on and read the result. The returned
value is not easily readable but it is 13 as expected.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ghci FibType.hs <span class="nt">-XDataKinds</span>
...
<span class="k">*</span>FibType&gt; :kind! Fibonacci <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S Z<span class="o">)))))))</span>
Fibonacci <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S <span class="o">(</span>S Z<span class="o">)))))))</span> :: Nat
<span class="o">=</span> <span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S '</span>Z<span class="o">))))))))))))</span></code></pre></figure>

<p>The code is as usual available on
<a href="https://github.com/madsbuch/fibonacci/tree/master/haskell">Github</a>.</p>

<p>Types alone does, however, not make a program. We need some kind of value
level implementation. In the next section I make a similar implementation
of the type level functions on the value level. Coupling the type and the
value in an one-to-one correspondence yields
<a href="https://wiki.haskell.org/Dependent_type">dependent programming</a></p>

<p>Dependent types are used to statically reason about programs and
put up guarantees that can be checked on compile time.
In this case we can set up the guarantee
that the code <em>actually</em> calculates the <em>n</em>‘th Fibonacci number.</p>

<h2 id="implementing-dependent-typing">Implementing Dependent Typing</h2>
<p>With dependent typing the type of a term <em>depends</em> on its value. In
Haskell we can benefit from making some parts of the types dependent.
This could for example be statically sized lists to make
matrix operations type-safe.</p>

<p>In this post I implement complete dependency between terms and their type.
The type for the Fibonacci term was implemented above. Now we just need to
write some code that couples it to the value level.</p>

<p>First we couple the datatype. I implemented a value level datatype,
<code class="highlighter-rouge">SNat</code>, which embeds its size.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="kr">data</span> <span class="kt">SNat</span> <span class="p">(</span><span class="n">a</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">SZ</span>   <span class="o">::</span> <span class="kt">SNat</span> <span class="kt">Z</span>
    <span class="kt">SS</span>   <span class="o">::</span> <span class="kt">SNat</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">S</span> <span class="n">n</span><span class="p">)</span></code></pre></figure>

<p>In the above the value level constructor has the type <code class="highlighter-rouge">SNat Z</code>. From
this type alone, we can read that it is the <em>zero</em> element.</p>

<p>The successor value constructor has the type <code class="highlighter-rouge">SNat n -&gt; SNat (S n)</code>.
Here the type is constructed depending on which number element we
construct.</p>

<p>An important property of above datatype is the bijection between
a datatype and its type. This is what we use to statically reason about
our programs and make sure certain guarantees are held.</p>

<p>After that we implement the addition function</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="n">add</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="kt">SNat</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span>
<span class="n">add</span> <span class="kt">SZ</span>      <span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">add</span> <span class="p">(</span><span class="kt">SS</span> <span class="n">a</span><span class="p">)</span>  <span class="n">b</span> <span class="o">=</span> <span class="kt">SS</span> <span class="p">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> </code></pre></figure>

<p>The value level add function stays completely true to the type-level
add function and is together with the Fibonacci function below fairly
self explanatory.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"> 
<span class="n">fibonacci</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">Fibonacci</span> <span class="n">n</span><span class="p">)</span>
<span class="n">fibonacci</span> <span class="kt">SZ</span>            <span class="o">=</span> <span class="kt">SZ</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="kt">SS</span> <span class="kt">SZ</span><span class="p">)</span>       <span class="o">=</span> <span class="p">(</span><span class="kt">SS</span> <span class="kt">SZ</span><span class="p">)</span>
<span class="n">fibonacci</span> <span class="p">(</span><span class="kt">SS</span> <span class="p">(</span><span class="kt">SS</span> <span class="n">n</span><span class="p">))</span>   <span class="o">=</span> <span class="n">add</span> <span class="p">(</span><span class="n">fibonacci</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">fibonacci</span> <span class="p">(</span><span class="kt">SS</span> <span class="n">n</span><span class="p">))</span></code></pre></figure>

<p>We now build a Fibonacci function where the returned value is bijective
to its type. Hence we are sure that what is computed at runtime is something
we can predict on compile time.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"> 
<span class="nv">$ </span>ghci <span class="nt">-XDataKinds</span> FibType.hs 
...
<span class="k">*</span>FibType&gt; <span class="nb">let </span>f <span class="o">=</span> fibonacci <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SS <span class="nv">$ </span>SZ
<span class="k">*</span>FibType&gt; :t f
f :: SNat
       <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S ('</span>S <span class="o">(</span><span class="s1">'S '</span>Z<span class="o">)))))))))))))</span>
<span class="k">*</span>FibType&gt; f
13</code></pre></figure>

<p>As expected the type of the term <em>fibonacci 7</em> has the type 13 (translated
from the unary representation to decimal). After evaluating the term we also
get the value <em>13</em>.</p>

<h1 id="applications-for-dependent-programming">Applications for Dependent Programming</h1>
<p>All above is perfectly good. But why bother writing so much more code
to just have a dependency between the value and its type? Well, for most
applications this is not necessary, but the technique can be used to set
strict guarantees in certain situations.</p>

<p>When you know the shape of the data-types on compile-time it can be
advantageous to model this shape into the program. This could be
some uses of matrices.</p>

<p>When implementing for example neural networks, the upper bound on
the topology is usually known when writing the code. In this case
one could use type safe matrix libraries to implement this functionality.</p>

<h1 id="conclusion">Conclusion</h1>
<p>In this post I first implemented the Fibonacci function on the type level.
I made a type for the <em>n</em>‘th element in the Fibonacci series. This was
done through data kinds and type families.</p>

<p>After this a value level implementation was implemented. It was implemented
in such a way that its type was bijective to its return value.</p>

<p>The dependency between the terms and the types was carried out through
GADTs which allows us to encode the type level natural in the types for
the values.</p>


        </section>
        <footer class="post-footer">
          <section class="share">
            
              
                <a class="icon-twitter" href="http://twitter.com/share?text=100+Days+of+Fibonacci+-+Day+9%2C+Haskell+Types&amp;url=http://madsbuch.com/blog/100-days-of-fibonacci-day-9-haskell-types"
                  onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
                <i class="fa fa-twitter"></i><span class="hidden">twitter</span>
                </a>
              
            
              
            
          </section>
        </footer>
        <div class="bottom-teaser cf">
          <div class="isLeft">
            <h5 class="index-headline featured"><span>Written by</span></h5>
            <section class="author">
              <div class="author-image" style="background-image: url(/blog/assets/images/author.png)">Blog Logo</div>
              <h4>Mads Buch</h4>
              <p class="bio"></p>
              <hr>
              <p class="published">Published <time datetime="2016-01-29 00:00">29 Jan 2016</time></p>
            </section>
          </div>
          
          <div class="isRight">
            <h5 class="index-headline featured"><span>Supported by</span></h5>
            <footer class="site-footer">
              <section class="poweredby">Proudly published with <a href="http://jekyllrb.com"> Jekyll</a></section>
              <a class="subscribe" href="/blog/feed.xml"> <span class="tooltip"> <i class="fa fa-rss"></i> You should subscribe to my feed.</span></a>
              <div class="inner">
                <section class="copyright">All content copyright <a href="/">Mads Buch</a> &copy; 2019<br>All rights reserved.</section>
              </div>
            </footer>
          </div>
        </div>
        
      </article>
    </main>
    <div class="bottom-closer">
      <div class="background-closer-image"  style="background-image: url(/blog/assets/images/cover.jpg)">
        Image
      </div>
      <div class="inner">
        <h1 class="blog-title">Mads Buch</h1>
        <h2 class="blog-description">Technical articles
</h2>
        <a href="/blog" class="btn">Back to Overview</a>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="/blog/assets/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/blog/assets/js/index.js"></script>
<script type="text/javascript" src="/blog/assets/js/readingTime.min.js"></script>
<script>
(function ($) {
  "use strict";
  $(document).ready(function(){

    var $window = $(window),
    $image = $('.post-image-image, .teaserimage-image');
    
      $window.on('scroll', function() {
        var top = $window.scrollTop();

        if (top < 0 || top > 1500) { return; }
        $image
          .css('transform', 'translate3d(0px, '+top/3+'px, 0px)')
          .css('opacity', 1-Math.max(top/700, 0));
      });
      $window.trigger('scroll');

      var height = $('.article-image').height();
      $('.post-content').css('padding-top', height + 'px');

      $('a[href*=#]:not([href=#])').click(function() {
        if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'')
         && location.hostname == this.hostname) {
          var target = $(this.hash);
          target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
          if (target.length) {
            $('html,body').animate({ scrollTop: target.offset().top }, 500);
            return false;
          }
        }
      });

  });
}(jQuery));
</script>


  </body>
</html>
